What type of graph should we use?
=================================
- seems like a directed graph is the right choice (direction matters in dependency).
- there is also a "hypergraph" where one edge can connect many. python-pygraph supports
it. Maybe we should use that ?!?

Event handlers:
===============
- are pieces of code that can run pre/post node/edge addition/removal.
- they get a handle to the mgr object when they do and the relevant data
	(node or edge in question and event type).
* should a "pre" handler be allowed to prevent the addition/removal of node/edge?
	it looks like a good idea.

What is in charge of the build?
===============================
The idea is that the node knows how to build itself.
	A source node.
		- reports that it is always up to date if the file exists.
		- when asked to build generates a build error.
			that tells the use that he/she must supply the node externally.
	A C object node:
		- reports that it is up to date according to dates of files.
		- when asked to build it runs the compiler.

Builders:
=========
- a builder is something that builds multiple nodes from multiple nodes.

When to check if everything is up to date?
==========================================
- when the user wants.
- when some event arrives (file has changed).

How to decice if something is up to date?
=========================================
- depth first traverse the whole graph.
- on each node ask the node if it is up to date.
- each node will have a uptodate checker attached to it when it is
	constructed.
- one updatedate checker will be the default (get a list of nodes
	and check the files).
- when a file is found not to be uptodate it is added to a "not up to date" list.

Avoiding cycles:
================
- the python-graph package has a method to find cycles. This should be activated
on edge addition and on edge addition only as it is the only modification that
has a chance of closing a cycle. If the new edge will close the cycle then it
is removed and an error is thrown.
- maybe in the future we will have a more efficient cycle detection whereby the
previous cycle detection algorithms will help the new edge addition to do it
cycle checking faster.

An error handling system:
=========================
An object that contains errors must be created. Any node which encounters
errors can submit errors and warnings to that object. The node can then
clear all errors FOR ITSELF ONLY via that object.
Error object may have line numbers, file number and more.

Cleaning:
=========
- how do I clean stuff?
	The idea is that clean will be an automatic feature.
	Any node which is not a source node could be cleaned by calling its clean method.
		all files will inherit the clean method which simply removes the file.
	I want to be able to see all stuff which is being cleaned and also see how many files
		are being cleaned.

Integration with source control management systems
==================================================
At first stage we will just take the source file list from the source control system.
I will first integrate with a file system walker and then with git.
This way I will not need to actually put the file names into the mgr but just tell it
to scan.
I could also add a black list feature of stuff that should not be taken as source files.
	(how about a mark INSIDE the file saying that it is not a source file?)
